# -*- coding: utf-8 -*-
"""dummy2ProjFor1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/sprksh-crypto/MachineLearningProjects/blob/main/dummy2ProjFor1.ipynb

I'm doing this dummy project to verify the code works as intended by using a smaller, easily examinable, scale. The larger layer set will be: 784-1000-10. I will use 4-5-2.

In the case for the 3 layer project: 4 is source, 5 is a second source, 2 will be the target.

I know in my larger code column goes to source, and row goes to target.
"""

import numpy as np

# Create a 4x5 NumPy array with random values
random_array = np.random.rand(5, 4)

random_array1= np.random.rand(2,5)

print(random_array)
print(random_array1)

import networkx as nx

col_labels = list(range(random_array.shape[1]))
row_labels = list(range(random_array.shape[0]))

print(col_labels)
print(row_labels)

# Create separate lists for source and target nodes
source_node_labels = [f"{0}:{j}" for j in range(random_array.shape[1])]
middle_node_labels = [f"{1}:{j}" for j in range(random_array.shape[0])]
target_node_labels = [f"{2}:{j}" for j in range(random_array1.shape[0])]

print(source_node_labels)
print(middle_node_labels)
print(target_node_labels)

G = nx.Graph()

G.add_nodes_from(source_node_labels, bipartite=0)
G.add_nodes_from(middle_node_labels, bipartite=1)
G.add_nodes_from(target_node_labels, bipartite=2)

print(G)

# Add weighted edges
for i in range(random_array.shape[0]):
    # Loop through the columns of the random_array
    for j in range(random_array.shape[1]):
        # Get the corresponding node labels
        source_node = source_node_labels[j]
        middle_node = middle_node_labels[i]
        weight = random_array[i][j]

        # Add an edge between the nodes with the weight from the random_array
        G.add_edge(source_node, middle_node, weight=weight)

for i in range(random_array1.shape[0]):
    # Loop through the columns of the random_array
    for j in range(random_array1.shape[1]):
        # Get the corresponding node labels
        middle_node = middle_node_labels[j]
        target_node = target_node_labels[i]
        weight = random_array1[i][j]

        # Add an edge between the nodes with the weight from the random_array
        G.add_edge(middle_node, target_node, weight=weight)

print(G)

nx.draw(G)

is_bipartite=nx.is_bipartite(G)
print(is_bipartite)

is_connected = nx.is_connected(G)
print(is_connected)

import networkx as nx
import matplotlib.pyplot as plt
from networkx.algorithms import bipartite

pos = dict()
pos.update( (n, (0, i)) for i, n in enumerate(source_node_labels) ) # put nodes from X at x=1
pos.update( (n, (1, i)) for i, n in enumerate(middle_node_labels) ) # put nodes from Y at x=2
pos.update( (n, (2, i)) for i, n in enumerate(target_node_labels) ) # put nodes from Y at x=3
nx.draw(G, pos=pos)
plt.show()

nx.draw_networkx_nodes(G, pos, node_size=200, node_color='skyblue')
nx.draw_networkx_labels(G, pos, font_size=8, font_color='black')

edge_labels = {(u, v): f"{G[u][v]['weight']:.2f}" for u, v in G.edges()}
for u, v, data in G.edges(data=True):
    weight = data['weight']
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=8)
    nx.draw_networkx_edges(G, pos, edgelist=[(u, v)])

plt.show()

# Get all edge attributes
edge_attributes = nx.get_edge_attributes(G, 'weight')

# Print the edge attributes
print(edge_attributes)

#Now, all my tasks have been completed for two layers, now I need to do this between two matrices and three layers.
